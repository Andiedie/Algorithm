/**
 * 不使用加减乘除，实现加法
 * 
 * 利用位运算
 * 异或又称不进位加法，
 * 0 ^ 0 = 0
 * 0 ^ 1 = 1
 * 1 ^ 0 = 1
 * 这些情况下，异或都和加法表现一直
 * 1 ^ 1 = 0
 * 在 1 异或 1 时，异或在本位还是完成了加法，但是没有进位
 * 
 * 例如 3 + 4
 *  0 1 1
 * ^1 0 0
 * =1 1 1 = 7
 * 
 * 例如 3 + 5
 *  0 1 1
 * ^1 0 1
 * =1 1 0 = 6
 * 没有低一位没有进行进位
 * 
 * 那么如何知道哪些位进行了进位呢？
 * 易知，只有当两个数的同一个位上都是 1 时，需要进位
 * 那么可以使用，与运算得知需要进位的地方
 *  0 1 1
 * &1 0 1
 * =0 0 1
 * 可知只有低一位需要进位，那么进位的结果是什么呢
 * 每个需要进位的位，实际上都是给上一位 +1
 * 那么只需要把需要进位的为左移一位，就可以得到进位值
 * 0 1 1
 * &1 0 1
 * =0 0 1
 * << 1 = 0 1 0
 * 需要进位的值就是 2
 * 
 * 那么问题就转化成了 异或出来的“无进位加法”与刚刚计算的“进位值”之间的加法
 * 只需要循环这个过程就行了，直到进位值是 0
 */
class Solution {
  public int Add(int num1, int num2) {
      while (num2 != 0) {
          int sum = num1 ^ num2;
          int carry = (num1 & num2) << 1;
          num1 = sum;
          num2 = carry;
      }
      return num1;
  }
}
