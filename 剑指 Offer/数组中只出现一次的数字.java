/**
 * 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。
 * 
 * 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。
 * 根据异或运算的性质：任何一个数字异或它自己都等于 0。
 * 也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。
 * 
 * 如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。
 * 如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。
 * 
 * 还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。
 * 因为其它数字都出现了两次，在异或中全部抵消掉了。
 * 由于这两个数字肯定不一样，那么这个异或结果肯定不为 0 ，也就是说在这个结果数字的二进制表示中至少就有一位为 1 。
 * 我们在结果数字中找到第一个为 1 的位的位置，记为第 N 位。
 * 现在我们以第 N 位是不是 1 为标准把原数组中的数字分成两个子数组
 * 第一个子数组中每个数字的第 N 位都为 1 ，而第二个子数组的每个数字的第 N 位都为 0 。
 * 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。
 */
class Solution {
  public void FindNumsAppearOnce(int [] array, int num1[], int num2[]) {
      int n = array.length;
      num1[0] = num2[0] = 0;
      if (n <= 1) {
          return;
      }
      int index = 0, sum = 0;
      for (int i : array) sum ^= i;
      while (index < 32) {
          if ((sum & (1 << index)) != 0) break;
          index++;
      }
      for (int i : array) {
          if ((i & (1 << index)) != 0) {
              num2[0] ^= i;
          } else {
              num1[0] ^= i;
          }
      }
      return;
  }
}
